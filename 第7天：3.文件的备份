# 文件备份，也就是文件复制，当我们处理重要文件时，为了防止该文件在处理时遭到不可逆的损坏，进而进行文件备份。
# 我们只针对备份的文件进行操作，从而避免对源文件的损害。下面我们通过一个实例来对文件备份进行学习。
# 需求：用户输入当前目录下任意文件名，程序完成对该文件的备份功能(备份文件名为，xx[备份]后缀，例如：test[备份].txt)

# 1.文件备份的步骤
# 根据上面的需求进行分析，备份文件名为，xx[备份]后缀，也就是要针对文件进行一个读和写的工作，并且备份的文件名中还要生成[备份]这样的名称。
# 这里，我们就将文件备份，分为以下三个步骤，逐一攻克。

# （1）接收用户输入的文件名
# （2）规划备份文件名
# （3）备份文件写入数据

# （1）接收用户输入的文件名
# 这里涉及到输入功能的实现，那么我们会想到input()函数，我们可以将其写为，input(“请输入您要备份的文件名：”)
# 然后，我们在定义一个变量来接收input的值

old_name = input("请输入您要备份的文件名：")

# 第一步的功能算是实现了

# （2）规划备份文件名
# 当（1）中输入了，比如“test.txt”的文件名后，那么按照需要，我们必须让生成的备份文件名变成，“test[备份].txt”。
# 因为这里input()函数接收的数据，是字符串类型的，所以不难想到，我们要实现备份的文件名的修改，可以用到我们前面学过的字符串的切片功能。
# 首先，我们要切取 . 左边的内容 test ，然后通过 + 来拼接字符串 "[备份]"，再通过 + 拼接右边的 "txt" 字符串。
# 左右两边切割的位置是从 . 开始的，所以下面我们要先确定 . 的位置，也就是确定 . 的下标。

index = old_name.rfind('.')

# 这个变量会接收到一个int类型的数值，也就是 . 的下标。
# 得到了 . 的下标，我们就可以利用字符串切片的语法对（1）中输入的文件名进行切片了。

# 通过 old_name[:index] 对文件名 test.txt 的左边进行切片，取到字符串 test
# 通过 old_name[index:] 对文件名 test.txt 的右边进行切片，取到字符串 txt
# 然后进行拼接，old_name[:index] + '[备份]' + old_name[index:]
# 当然，这需要定义一个变量来接收，最后写为：

new_name = old_name[:index] + '[备份]' + old_name[index:]

# 第二部的功能也实现了

# （3）备份文件写入数据
# 好了，（1）（2）都完成了，下面就需要利用到我们今天学习的文件操作知识来完成，备份文件写入数据了。
# 首先，我们思考一下，想要实现（3），需要实现哪些功能呢？
# 首先，我们要打开（1）中输入的文件，以及（2）中生成的新文件，当然这时候的新文件只是有了名字，其中还是空的，没有写入内容的。
# 其次，我们要将（1）中的文件，写入（2）中去。
# 最后，将（1）（2）中的文件关闭。

# 首先，输入 old_f = open(old_name,'rb') 以及 new_f = open(new_name,'wb') 打开两个文件
# 其次，输入：
  while True:                    # --> 利用while()函数，循环读取数据而不是一次性读取数据，是为了提高代码运行的效率。
    content = old_f.read(1024)   # --> 注意，这里括号中的1024，表示一次性读取的数据的大小，是为了提高代码运行的效率，当然也可以不填数据。
    if content == 0:             # --> 设置while循环中断的条件，old_f中的数据读完了即可终止。
      break
    new_f.write(content)         # --> 将读取到变量content中的数据，写入new_f中来。
    
  old_f.close()                  # --> 不要忘了关闭两个打开的文件，不然会造成内存的持续占用。
  new_f.close()
  
# 至此，三个步骤的功能都完成了，将是三块代码整合到一起，就能实现文件备份的功能了。
